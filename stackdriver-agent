#!/bin/bash
#
# stackdriver-agent    Startup script for the Stackdriver agent
# chkconfig: 2345 86 15
# description: System metrics collection agent for Stackdriver
# processname: stackdriver-collectd
# config: /etc/sysconfig/stackdriver
# config: /opt/stackdriver/collectd/etc/collectd.conf
# pidfile: /var/run/stackdriver-agent.pid

### BEGIN INIT INFO
# Provides: stackdriver-agent
# Required-Start: $local_fs $remote_fs $network $syslog $named
# Required-Stop: $local_fs $remote_fs $network $syslog
# Short-Description: start and stop Stackdriver Agent
# Description: The Stackdriver Agent is used with the Stackdriver monitoring SaaS service.
# Default-Start: 2 3 4 5
# Default-Stop: 0 1 6
### END INIT INFO

# Source function library.
. /etc/init.d/functions

RETVAL=0
ARGS=""
prog="stackdriver-collectd"
pidfile=/var/run/stackdriver-agent.pid
CONFIG=/opt/stackdriver/collectd/etc/collectd.conf
CONFIG_TEMPLATE=/opt/stackdriver/collectd/etc/collectd.conf.tmpl
GCM_CONFIG_TEMPLATE=/opt/stackdriver/collectd/etc/collectd-gcm.conf.tmpl

JAVA_LIB_DIR=""

if [ -r /etc/default/$prog ]; then
    . /etc/default/$prog
fi
if [ -r /etc/sysconfig/stackdriver ]; then
    . /etc/sysconfig/stackdriver
fi

# Attempt to discover the location of the Java libraries.
find_libjvm_so () {
    local java_lib_dir
    local java_home=$(dirname "$(readlink -f "$(bash -lc "which java 2>/dev/null")")")/..
    [ "$java_home" = "./.." ] && return
    local lib_subdirs=("lib/amd64/server" "lib/x64/server" "lib/i386/server")
    local lib_subdirs_with_jre=()
    for subdir in "${lib_subdirs[@]}"; do
        lib_subdirs_with_jre+=("$subdir" "jre/$subdir")
    done
    for libdir in "${lib_subdirs_with_jre[@]/#/$java_home/}"; do
        if [ -f "$libdir/libjvm.so" ]; then
            java_lib_dir="$libdir"
            break
        fi
    done
    echo $java_lib_dir
}

[ -n "$JAVA_LIB_DIR" ] || JAVA_LIB_DIR=$(find_libjvm_so)
if [ -n "$JAVA_LIB_DIR" ]; then
    export LD_LIBRARY_PATH="$LD_LIBRARY_PATH:$JAVA_LIB_DIR"
fi

get_instance_id () {
    local iid

    # allow override of instance id in sysconfig file
    if [ -n "$INSTANCE_ID" ]; then
        iid=$INSTANCE_ID
    elif [ -r /opt/stackdriver/hostid ]; then
        iid=$(cat /opt/stackdriver/hostid)
    # RS: Check Rackspace first because we can fail quickly.
    elif [[ -x /usr/bin/xenstore-read && $(/usr/bin/xenstore-read vm-data/provider_data/provider) = "Rackspace" ]]; then
        iid=$(/usr/bin/xenstore-read name |sed -e 's/^instance-//')
    elif [ -z "$SKIP_METADATA_CHECKS" ]; then
        # AWS: If we're on EC2, this ought to return the instance id.
        iid=$(curl --silent -f http://169.254.169.254/latest/meta-data/instance-id 2>/dev/null)
        if [ -z "$iid" ]; then
            # that failed.  let's try to see if it looks like we're on GCE
            iid=$(curl --silent -f -H 'Metadata-Flavor: Google' http://169.254.169.254/computeMetadata/v1/instance/id 2>/dev/null)
        fi
    elif [ -r /sys/hypervisor/uuid -a $(cat /sys/hypervisor/version/extra |grep -c amazon) -eq 0 ]; then
        iid=$(cat /sys/hypervisor/uuid)
    else
        echo 'Unable to discover an id for this machine!' >&2
    fi

    echo $iid
}

get_collectd_endpoint () {
    for endpoint in collectd-gateway.google.stackdriver.com collectd-gateway.stackdriver.com; do
        if [[ "200" = $(curl --silent -f -s -w "%{http_code}" --retry 1 -o /dev/null https://${endpoint}/v1/agent-test?stackdriver-apikey=${STACKDRIVER_API_KEY} 2>/dev/null) ]]; then
            echo $endpoint
            return
        fi
    done
    echo 'Unable to determine collectd endpoint!' >&2
    return 1
}

gen_hostid() {
    echo "Generating a host id"
    uuidgen > /opt/stackdriver/hostid
    return 0
}

gen_config() {
    if [ "$AUTOGENERATE_COLLECTD_CONFIG" = "no" ]; then
        return
    fi

    AUTOGENERATE_HEADER="# NOTE: This file is auto-generated and will be overwritten unless you set
#     AUTOGENERATE_COLLECTD_CONFIG=\"no\"
# in /etc/sysconfig/stackdriver
"
    if [ -z "$USE_GCM_API" -a -n "$DETECT_GCM" ]; then
        # automatically determine if we should be using the GCM API
        # first, see if the instance has a monitoring.write scope
        INSTANCE_SCOPES=$(curl --silent -f -H "Metadata-Flavor: Google" http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/scopes 2>/dev/null)$'\n'
        if [[ $INSTANCE_SCOPES == *"/monitoring.write"$'\n'* || $INSTANCE_SCOPES == *"/monitoring"$'\n'* || $INSTANCE_SCOPES == *"/cloud-platform"$'\n'* ]]; then
            echo "Found sufficient authorization scope for the GCM API"
            USE_GCM_API="yes"
        # second, see if the application default credential file is in the system location
        elif [ -f "${GOOGLE_APPLICATION_CREDENTIALS:-/etc/google/auth/application_default_credentials.json}" ]; then
            echo "Found a credentials file"
            USE_GCM_API="yes"
        # or we're not using the gcm api
        else
            echo "Not authorized to talk to the GCM API, falling back on legacy" >&2
            USE_GCM_API="no"
        fi
    fi
    # now see if we should be using write_gcm and use the appropriate template if so
    if [ "$USE_GCM_API" = "yes" ]; then
        echo "$AUTOGENERATE_HEADER" > $CONFIG
        cat $GCM_CONFIG_TEMPLATE >> $CONFIG
        return
    fi


    if [ -z "$STACKDRIVER_API_KEY" ]; then
        STACKDRIVER_API_KEY=$(curl --silent -f -H "Metadata-Flavor: Google" http://169.254.169.254/computeMetadata/v1/project/attributes/stackdriver-agent-key 2>/dev/null)
        if [ -z "$STACKDRIVER_API_KEY" ]; then
            echo "Need to set STACKDRIVER_API_KEY in /etc/sysconfig/stackdriver" >&2
            return 1
        fi
    fi
    local IID=$(get_instance_id)
    if [ -z "$IID" ]; then
        echo "Unable to discover instance id" >&2
    return 1
    fi
    if [ -z "$COLLECTD_ENDPOINT"]; then
        COLLECTD_ENDPOINT=$(get_collectd_endpoint)
        if [[ $? -ne 0 ]]; then
            return 1
        fi
    fi
    echo "$AUTOGENERATE_HEADER" > $CONFIG
    sed -e "s/{IID}/$IID/; s/{API_KEY}/$STACKDRIVER_API_KEY/; s|{COLLECTD_ENDPOINT}|$COLLECTD_ENDPOINT|" $CONFIG_TEMPLATE >> $CONFIG
}

start () {
    echo -n $"Starting $prog: "

    GOOGLE_MONITORING_ENABLE=$(curl --silent -f -H "Metadata-Flavor: Google" http://169.254.169.254/computeMetadata/v1/instance/attributes/google-monitoring-enable 2>/dev/null)
    if [ -n "$GOOGLE_MONITORING_ENABLE" -a "$GOOGLE_MONITORING_ENABLE" = "0" ]; then
        echo "Disabled via metadata"
        return 0
    fi

    # allow setting a proxy
    if [ -n "$PROXY_URL" ]; then
        export https_proxy=$PROXY_URL
    fi

    if ! gen_config; then
        echo "Not starting. Configuration error!" >&2
        return 1
    fi

    if [ -r "$CONFIG" ]; then
        LD_LIBRARY_PATH="$LD_LIBRARY_PATH:/opt/stackdriver/collectd/lib64:/opt/stackdriver/collectd/lib" daemon /opt/stackdriver/collectd/sbin/stackdriver-collectd -C "$CONFIG" -P "$pidfile"
        RETVAL=$?
        echo
        [ $RETVAL -eq 0 ] && touch /var/lock/subsys/$prog
    else
        echo "Can't read agent configuration file: $CONFIG"
        RETVAL=1
    fi
    return $RETVAL
}

stop () {
    echo -n $"Stopping $prog: "
    killproc $prog
    RETVAL=$?
    echo

    [ $RETVAL -eq 0 ] && rm -f /var/lock/subsys/$prog
}

# See how we were called.
case "$1" in
  start)
    start
    ;;
  stop)
    stop
    ;;
  status)
    status -p $pidfile $prog
    ;;
  restart|reload)
    stop
    start
    ;;
  condrestart)
    [ -f /var/lock/subsys/$prog ] && stop && start || :
    ;;
  genhostid)
    gen_hostid
    ;;
  *)
    echo $"Usage: $0 {start|stop|status|restart|reload|condrestart|genhostid}"
    exit 1
esac

exit $?

# vim:syntax=sh
